# Revenge of Discount Programming Devices
One of our security analysts learned to avoid printing out flag when obfuscating code!
Unfortunately, now they've lost that flag.
Maybe you can help them get it back.

## Solution
Immediately, I opened the file in a HEX editor to check the filetype and content. I saw that it was an ELF-file, but more interestingly, I found mentions of python and pyinstaller. This means that it is fairly trivial to extract the original content (python script).

To get the original script, I first had to unpack the executable. This can be done using a script like [pyinstxtractor](https://github.com/extremecoders-re/pyinstxtractor). Now, we have the bytecode, which isn't very readable, but can easily be converted to the original code. I decided to use an [online service](https://pylingual.io/view_chimera?identifier=f15db1b6113394fb88fb6abdde75c36ee1f26a156c58a84049e12c59c1152576) I'd used in the past. This gave me the following script (truncated for readability):

```python
_ = lambda __: __import__('zlib').decompress(__import__('base64').b64decode(__[::-1]))
exec(_(b'==gbELVp/9+9 [...] '))
```

The file was quite large, but the obfuscation is pretty clear. After decoding it, I realized that it was encoded several times. Not wanting to spend hours doing this manually, I made a script to automatically decode it:

```python
import base64
import zlib
import re

# Path to the encoded file
file_path = 'encoded.txt'

# Perform repeated decoding and decompression up to 30 times
for i in range(1000):
    with open(file_path, 'rb') as file:
        encoded_data = file.read()

    # Extract the content inside the b'...'
    match = re.search(rb"b'(.*)'", encoded_data)
    if match:
        encoded_data = match.group(1)

    try:
        # Reverse the encoded data, base64 decode, then zlib decompress
        reversed_data = encoded_data[::-1]
        decoded_data = base64.b64decode(reversed_data)
        decompressed_data = zlib.decompress(decoded_data)
        
        # Save the decompressed data back to the file
        with open(file_path, 'wb') as file:
            file.write(decompressed_data)

        print(f"Iteration {i+1}: Successfully decoded and decompressed. File size: {len(decompressed_data)} bytes")

    except Exception as e:
        print(f"Decoding stopped at iteration {i+1} due to error: {e}")
        break

# Print final result after all iterations
with open(file_path, 'rb') as file:
    print(file.read().decode('utf-8', errors='replace'))
```
This gave me another script, full of ASCII characters:

```python
# ordlist = [102, 114, 111 [...] 0, 32, 95, 95, 95, 95, 95, 95, 41, 41]
# print(''.join(chr(values) for values in ordlist))
print('Save your comments about this obfuscation.')
```
All of the code, except for the very last line, was commented out. I saved it to a new file and uncommented it. Then, I ran the script, which gave me yet another script:

```python
from itertools import cycle as _______;________=print;_________=''.join;__________=chr;___________=zip;_ = b"\x64\x35\x30 [...] x45\x4c\x48";______ = [___^____ for ___,____ in zip(__, _______(_))];________(_________(__________(_____) for _____ in ______))
Save your comments about this obfuscation.
```

..which again, gave me a script that looked similar to the very first one:

```python
_ = lambda __ : __import__('zlib').decompress(__import__('base64').b64decode(__[::-1]));exec((_)(b'==wrVsSA [...] wJe'))
```
Finally, I could decode the content of this script (using my decode script) to get the flag.